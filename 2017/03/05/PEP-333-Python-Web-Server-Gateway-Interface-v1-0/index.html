<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="WSGI,PEP 333," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="原文地址    PEP: 333    Title: Python Web Server Gateway Interface v1.0   Author: Phillip J. Eby    Discussions-To: Python Web-SIG &lt; web-sig at python.org &gt;   Status: Final   Type: Informational   C">
<meta property="og:type" content="article">
<meta property="og:title" content="PEP 333 -- Python Web Server Gateway Interface v1.0 翻译">
<meta property="og:url" content="http://yoursite.com/2017/03/05/PEP-333-Python-Web-Server-Gateway-Interface-v1-0/index.html">
<meta property="og:site_name" content="bingtel">
<meta property="og:description" content="原文地址    PEP: 333    Title: Python Web Server Gateway Interface v1.0   Author: Phillip J. Eby    Discussions-To: Python Web-SIG &lt; web-sig at python.org &gt;   Status: Final   Type: Informational   C">
<meta property="og:locale">
<meta property="article:published_time" content="2017-03-05T11:34:02.000Z">
<meta property="article:modified_time" content="2022-01-16T11:54:52.852Z">
<meta property="article:author" content="Wang Yibing">
<meta property="article:tag" content="WSGI">
<meta property="article:tag" content="PEP 333">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/03/05/PEP-333-Python-Web-Server-Gateway-Interface-v1-0/"/>





  <title> PEP 333 -- Python Web Server Gateway Interface v1.0 翻译 | bingtel </title>
<meta name="generator" content="Hexo 6.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?728a3326befbc818061494f87805db56";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">bingtel</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">木犹如此</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>
<div style='display:none;'>
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1257109371'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1257109371' type='text/javascript'%3E%3C/script%3E"));</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?728a3326befbc818061494f87805db56";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</div>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/05/PEP-333-Python-Web-Server-Gateway-Interface-v1-0/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="bingtel">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="bingtel" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                PEP 333 -- Python Web Server Gateway Interface v1.0 翻译
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-05T19:34:02+08:00">
                2017-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0333/">原文地址</a></p>
<table>
<thead>
<tr>
<th>PEP:</th>
<th>333</th>
</tr>
</thead>
<tbody><tr>
<td>Title:</td>
<td>Python Web Server Gateway Interface v1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Phillip J. Eby <pje at telecommunity.com></td>
</tr>
<tr>
<td>Discussions-To:</td>
<td>Python Web-SIG &lt; web-sig at python.org &gt;</td>
</tr>
<tr>
<td>Status:</td>
<td>Final</td>
</tr>
<tr>
<td>Type:</td>
<td>Informational</td>
</tr>
<tr>
<td>Created:</td>
<td>07-Dec-2003</td>
</tr>
<tr>
<td>Post-History:</td>
<td>07-Dec-2003, 08-Aug-2004, 20-Aug-2004, 27-Aug-2004, 27-Sep-2010</td>
</tr>
<tr>
<td>Superseded-By:</td>
<td>3333</td>
</tr>
</tbody></table>
<p>Contents</p>
<ul>
<li><a href="#preface">序言(Preface)</a></li>
<li><a href="#abstract">概要(Abstract)</a></li>
<li><a href="#rationale-and-goals">理论说明和目标(Rationale and Goals)</a></li>
<li><a href="#specification-overview">规范概述(Specification Overview)</a><ul>
<li><a href="#the-application-framework-side">应用/框架端(The Application/Framework Side)</a></li>
<li><a href="#the-server-gateway-side">服务器/网关端(The Server/Gateway Side)</a></li>
<li><a href="#middleware-components-that-play-both-sides">中间件: 两面派的组件 (Middleware: Components that Play Both Sides)</a></li>
</ul>
</li>
<li><a href="#specification-details">规范细节(Specification Details)</a><ul>
<li><a href="#environ-variables">environ 变量(environ Variables)</a><ul>
<li><a href="#input-and-error-streams">输入流和错误流(Input and Error Streams)</a></li>
</ul>
</li>
<li><a href="#the-start-response-callable">可调用的start_response()(The start_response() Callable)</a><ul>
<li><a href="#handling-the-content-length-header">处理Content-Length(Handling the Content-Length Header)</a></li>
</ul>
</li>
<li><a href="#buffering-and-streaming">缓冲和流(Buffering and Streaming)</a><ul>
<li><a href="#middleware-handling-of-block-boundaries">中间件对块边界的处理(Middleware Handling of Block Boundaries)</a></li>
<li><a href="#the-write-callable">可调用的write()(The write() Callable)</a></li>
</ul>
</li>
<li><a href="#unicode-issues">Unicode问题(Unicode Issues)</a></li>
<li><a href="#error-handling">错误处理(Error Handling)</a></li>
<li><a href="#http-1-1-expect-continue">HTTP 1.1 Expect/Continue</a></li>
<li><a href="#other-http-features">其它的HTTP特性(Other HTTP Features)</a></li>
<li><a href="#thread-support">线程支持(Thread Support)</a></li>
</ul>
</li>
<li><a href="#implementation-application-notes">实现/应用注意事项(Implementation/Application Notes)</a><ul>
<li><a href="#server-extension-apis">服务器拓展APIs(Server Extension APIs)</a></li>
<li><a href="#application-configuration">应用配置(Application Configuration)</a></li>
<li><a href="#url-reconstruction">URL重构(URL Reconstruction)</a></li>
<li><a href="supporting-older-2-2-versions-of-python">支持(&lt;2.2)老版本的Python(Supporting Older (&lt;2.2) Versions of Python)</a></li>
<li><a href="#optional-platform-specific-file-handling">可选的特定平台的文件处理(Optional Platform-Specific File Handling)</a></li>
</ul>
</li>
<li><a href="#questions-and-answers">问题和回答(Questions and Answers)</a></li>
<li><a href="#proposed-under-discussion">拟议/讨论中(Proposed/Under Discussion)</a></li>
<li><a href="#acknowledgements">致谢(Acknowledgements)</a></li>
<li><a href="#references">参考资料(References)</a></li>
<li><a href="#copyright">版权(Copyright)</a></li>
</ul>
<h2 id="序言-Preface"><a href="#序言-Preface" class="headerlink" title="序言(Preface)"></a><a id="preface">序言(Preface)</a></h2><p>说明：本规范的更新版本支持Python 3.x，包括社区勘误、补遗、澄清等，请参阅<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-3333/">PEP3333</a></p>
<span id="more"></span>

<h2 id="概要-Abstract"><a href="#概要-Abstract" class="headerlink" title="概要(Abstract)"></a><a id="abstract">概要(Abstract)</a></h2><p>该文档指定了web服务器和Python web应用或web框架之间的标准接口，以提高web应用在一系列web服务器间的移植性。</p>
<h2 id="理论说明和目标-Rationale-and-Goals"><a href="#理论说明和目标-Rationale-and-Goals" class="headerlink" title="理论说明和目标(Rationale and Goals)"></a><a id="rationale-and-goals">理论说明和目标(Rationale and Goals)</a></h2><p>Python当前拥有众多的web框架，如：Zope, Quixote, Webware, SkunkWeb, PSO, and Twisted Web–这仅仅是列举一小部分。对于Python新人而言，(框架的)可选择性太多也是个问题：通常来说，他们所选择的框架会限制住可能使用的web服务器，反之亦然。</p>
<p>对比发现，尽管Java也有者众多可用的web框架，但是<code>Servlet</code>API却使<code>使用Java web框架的应用能够在任意支持servlet API的服务器中运行</code>成为可能。</p>
<p>Python web服务器中大量使用这样的API的话——无论是Python语言实现的服务器(比如：Medusa)、嵌入了Python的服务器(如：mod_python)还是通过网关协议调用了Python的服务器(如：CGI, FastCGI等)——将使得框架的选择和服务器的选择分离，使得用户自由使用框架、服务器组合，同时使得框架、服务器的开发者专注于他们各自的的一亩三分地(<code>preferred area of specialization</code>)。</p>
<p>因此，本Python增强建议书(PEP)提出了一个用于web服务器和web应用(或框架)之间的简单且通用的接口：<code>Python Web Server Gateway Interface (WSGI)</code>。</p>
<p>但仅是一份WSGI的声明对处理已存在的Python应用服务器和框架而言，并没有意义。服务器、框架的作者、维护者们必须真正实现WSGI，以便让WSGI生效。</p>
<p>然而，当前并没有支持WSGI的服务器、框架，对于实现WSGI的作者而言，也没有立即的回报。因而，WSGI<strong>一定要</strong>容易实现，这样开发者实现WSGI的成本也会适度降低。</p>
<p>因此，服务器、框架实现WSGI的简便性对于WSGI的应用推广至关重要，所以(简便性)是WSGI任何设计决策的首要原则。</p>
<p>但也要注意到，框架作者实现(WSGI)的简便性和web应用作者使用框架的简便性可不是一回事。WSGI向框架开发者提供了一个绝对”纯粹(no frills)”的接口，因为像响应对象、cookies处理这些奇特的功能，只会妨碍已有的框架处理这些问题。再说一遍：WSGI的目标是让现有的服务器和应用(框架)之间的通信更加方便，而不是实现一个新的Web框架。</p>
<p>请注意，这个目标也让WSGI不能依赖于未在已发布的Python版本中出现的功能。所以，本规范不提议也不要求任何新的标准库模块， 并且WSGI也不要求Python 2.2.2或者更高版本的特性。(但是，在Python的后续版本中，如果标准库提供的web服务器提供了对WSGI的支持，将是很赞的事)</p>
<p>除了要方便今后服务器、框架去实现之外，WSGI规范也要方便创建<code>请求预处理器</code>(request preprocessors)、<code>响应后处理器</code>(response postprocessors)以及其它的基于WSGI的<code>中间件</code>(middleware)组件，这些组件对于包含它们的服务器而言，像个应用;而对于它们所包含的应用而言，又像个服务器。</p>
<p>如果中间件既简单又鲁棒(robust)、WSGI在服务器和框架中广泛使用的话，那么就有可能出现一种全新的Python web应用框架：一个松耦合地包含多个WSGI中间件的框架。事实上，现有框架的作者也许想要重构已存在的框架服务并以此方式提供服务，使得服务更像是使用WSGI的库，而不是一个单一的框架。此举会允许开发者选择具有<code>单项优势</code>(best-of-breed)的组件以实现特定的功能，而不是必须要受到单个框架的方方面面(pros and cons)的约束.</p>
<p>当然，写本文的时候，这一天还很遥远。同时，使得任何框架能够自由服务器使用，是WSGI规范的短期目标。</p>
<p>最后，要说明下：WSGI的当前版本不会给出在web服务器或服务器网关(<code>server gateway</code>)中发布应用的任何解决方案。截止目前，这是服务器或者网关所定义的必要实现。当足够多的实现了WSGI的服务器、框架提供了多样的部署要求的经验以后，创建另一个描述符合WSGI规范的服务器、应用框架部署标准的PEP才可能会有意义。</p>
<h2 id="规范概述-Specification-Overview"><a href="#规范概述-Specification-Overview" class="headerlink" title="规范概述(Specification Overview)"></a><a id="specification-overview">规范概述(Specification Overview)</a></h2><p>WSGI接口连接两端：服务器或网关端、应用或框架端。服务器端会调用应用端提供的一个可调用(callable)对象。server或者gateway决定该对象如何被提供。人们认为，一些服务器(或网关)会要求应用开发者编写一段短小的脚本来创建一个服务器(或者网关)的实例，并向该实例提供一个应用对象。其它的服务器和网关会使用配置文件或其它方式来确定应用对象从哪里引入，或以其它方式获得。</p>
<p>除了<code>纯</code>(<code>pure</code>)服务器/网关和应用/框架之外，也可能创建实现本规范两端的<code>中间件</code>组件。这样的组件对于包含它们的服务器而言就像个应用，对于所包含的应用而言就像个服务器，能够用于提供额外的API、内容转换、导航(<code>navigation</code>)以及其它有用的功能。</p>
<p>贯穿本文，我们将使用术语”a callable”来表示”一个函数、方法、类或者一个实现了__call__方法的实例”。这取决于那些实现了<code>callable </code>的服务器、网关或者应用根据自身需要来选择合适的实现方式。相反，一个调用了一个callable对象的服务器、网关或者应用<strong>一定不能</strong>依赖于所提供的是哪一种<code>callable</code>方式.Callable对象只是用来被调用的，而不是要被<code>自省</code>(译者注：了解实现)的。</p>
<h3 id="应用-框架端-The-Application-Framework-Side"><a href="#应用-框架端-The-Application-Framework-Side" class="headerlink" title="应用/框架端(The Application/Framework Side)"></a><a id="the-application-framework-side">应用/框架端(The Application/Framework Side)</a></h3><p>应用对象是个接受两个参数的简单的callable对象。术语<code>object</code>不能被误认为是要求一个真实的对象实例：一个函数、方法、类或者一个实现了``<strong>call</strong><code>方法</code>的实例都可以作为一个应用对象。应用对象一定要能够多次调用，实际上所有的服务器或者网关(除了CGI)都会反复请求。</p>
<p>(要注意:尽管我们把它看做应用对象，但并不意味着应用开发者要把WSGI作为API调用。只是说，应用开发者继续使用现有的、更高层次的框架来开发他们的应用。WSGI是面向框架、服务器开发者的工具，而不是为应用开发者直接提供支持的。)</p>
<p>这里有两个应用对象的例子：一个是function对象，另外一个是class，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">def simple_app(environ, start_response):</span><br><span class="line">    &quot;&quot;&quot;可能是最简单的应用对象(Simplest possible application object)&quot;&quot;&quot;</span><br><span class="line">    status = &#x27;200 OK&#x27;</span><br><span class="line">    response_headers = [(&#x27;Content-type&#x27;, &#x27;text/plain&#x27;)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    return [&#x27;Hello world!\n&#x27;]</span><br><span class="line">    </span><br><span class="line">class AppClass:</span><br><span class="line">    &quot;&quot;&quot;Produce the same output, but using a class</span><br><span class="line">    </span><br><span class="line">    使用类产生(和上述function)相同的输出</span><br><span class="line"></span><br><span class="line">    (Note: &#x27;AppClass&#x27; is the &quot;application&quot; here, so calling it</span><br><span class="line">    returns an instance of &#x27;AppClass&#x27;, which is then the iterable</span><br><span class="line">    return value of the &quot;application callable&quot; as required by</span><br><span class="line">    the spec).</span><br><span class="line">    </span><br><span class="line">    (注意：`AppClass`就是`应用`,所以调用它时，会返回一个`AppClass`实例,</span><br><span class="line">    该实例是可迭代的，会按照规范要求返回`application callable`的值)</span><br><span class="line"></span><br><span class="line">    If we wanted to use *instances* of &#x27;AppClass&#x27; as application</span><br><span class="line">    objects instead, we would have to implement a &#x27;__call__&#x27;</span><br><span class="line">    method, which would be invoked to execute the application,</span><br><span class="line">    and we would need to create an instance for use by the</span><br><span class="line">    server or gateway.</span><br><span class="line">    </span><br><span class="line">    如果我们想使用AppClass的实例来作为应用对象，我们要实现一个`__call__`</span><br><span class="line">    方法,该方法会被调用执行，并且我们需要创建一个实例供服务器/网关调用。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, environ, start_response):</span><br><span class="line">        self.environ = environ</span><br><span class="line">        self.start = start_response</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        status = &#x27;200 OK&#x27;</span><br><span class="line">        response_headers = [(&#x27;Content-type&#x27;, &#x27;text/plain&#x27;)]</span><br><span class="line">        self.start(status, response_headers)</span><br><span class="line">        yield &quot;Hello world!\n&quot;</span><br></pre></td></tr></table></figure>
<h3 id="服务器-网关端-The-Server-Gateway-Side"><a href="#服务器-网关端-The-Server-Gateway-Side" class="headerlink" title="服务器/网关端(The Server/Gateway Side)"></a><a id="the-server-gateway-side">服务器/网关端(The Server/Gateway Side)</a></h3><p>每当从HTTP客户端收到一个请求，服务器或者网关就立即调用一次callable的应用对象并把请求定向到应用。为了方便阐述，这里有一个由函数实现的简单的CGI网关，该函数以应用对象作为参数。注意：这个简单的例子的错误处理机制是有限的，因为通常而言，未被捕获的异常会被转储到<code>sys.stderr</code>并被web服务器记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import os, sys</span><br><span class="line"></span><br><span class="line">def run_with_cgi(application):</span><br><span class="line"></span><br><span class="line">    environ = dict(os.environ.items())</span><br><span class="line">    environ[&#x27;wsgi.input&#x27;]        = sys.stdin</span><br><span class="line">    environ[&#x27;wsgi.errors&#x27;]       = sys.stderr</span><br><span class="line">    environ[&#x27;wsgi.version&#x27;]      = (1, 0)</span><br><span class="line">    environ[&#x27;wsgi.multithread&#x27;]  = False</span><br><span class="line">    environ[&#x27;wsgi.multiprocess&#x27;] = True</span><br><span class="line">    environ[&#x27;wsgi.run_once&#x27;]     = True</span><br><span class="line"></span><br><span class="line">    if environ.get(&#x27;HTTPS&#x27;, &#x27;off&#x27;) in (&#x27;on&#x27;, &#x27;1&#x27;):</span><br><span class="line">        environ[&#x27;wsgi.url_scheme&#x27;] = &#x27;https&#x27;</span><br><span class="line">    else:</span><br><span class="line">        environ[&#x27;wsgi.url_scheme&#x27;] = &#x27;http&#x27;</span><br><span class="line"></span><br><span class="line">    headers_set = []</span><br><span class="line">    headers_sent = []</span><br><span class="line"></span><br><span class="line">    def write(data):</span><br><span class="line">        if not headers_set:</span><br><span class="line">             raise AssertionError(&quot;write() before start_response()&quot;)</span><br><span class="line"></span><br><span class="line">        elif not headers_sent:</span><br><span class="line">             # Before the first output, send the stored headers</span><br><span class="line">             status, response_headers = headers_sent[:] = headers_set</span><br><span class="line">             sys.stdout.write(&#x27;Status: %s\r\n&#x27; % status)</span><br><span class="line">             for header in response_headers:</span><br><span class="line">                 sys.stdout.write(&#x27;%s: %s\r\n&#x27; % header)</span><br><span class="line">             sys.stdout.write(&#x27;\r\n&#x27;)</span><br><span class="line"></span><br><span class="line">        sys.stdout.write(data)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">    def start_response(status, response_headers, exc_info=None):</span><br><span class="line">        if exc_info:</span><br><span class="line">            try:</span><br><span class="line">                if headers_sent:</span><br><span class="line">                    # Re-raise original exception if headers sent</span><br><span class="line">                    raise exc_info[0], exc_info[1], exc_info[2]</span><br><span class="line">            finally:</span><br><span class="line">                exc_info = None     # avoid dangling circular ref</span><br><span class="line">        elif headers_set:</span><br><span class="line">            raise AssertionError(&quot;Headers already set!&quot;)</span><br><span class="line"></span><br><span class="line">        headers_set[:] = [status, response_headers]</span><br><span class="line">        return write</span><br><span class="line"></span><br><span class="line">    result = application(environ, start_response)</span><br><span class="line">    try:</span><br><span class="line">        for data in result:</span><br><span class="line">            if data:    # don&#x27;t send headers until body appears</span><br><span class="line">                write(data)</span><br><span class="line">        if not headers_sent:</span><br><span class="line">            write(&#x27;&#x27;)   # send headers now if body was empty</span><br><span class="line">    finally:</span><br><span class="line">        if hasattr(result, &#x27;close&#x27;):</span><br><span class="line">            result.close()</span><br></pre></td></tr></table></figure>

<h3 id="中间件-两面派的组件-Middleware-Components-that-Play-Both-Sides"><a href="#中间件-两面派的组件-Middleware-Components-that-Play-Both-Sides" class="headerlink" title="中间件: 两面派的组件 (Middleware: Components that Play Both Sides)"></a><a id="middleware-components-that-play-both-sides">中间件: 两面派的组件 (Middleware: Components that Play Both Sides)</a></h3><p>注意：单个对象对于某(些)个应用对象而言，扮演着服务器的角色，同时对于某(些)个服务器而言，又表现的像个应用。<br>这样的<code>中间件</code>有着如下功能：</p>
<ul>
<li>在重写<code>environ</code>之后，相应地根据目标URL把请求发到对应的应用对象。</li>
<li>允许多个应用或者框架并行允许。</li>
<li>通过网络来转发请求和相应，实现负载均衡和远程处理。</li>
<li>对内容进行后续处理，比如应用XSL样式表</li>
</ul>
<p>通常情况下，中间件对于<code>服务器/网关</code>、<code>应用/框架</code>的接口而言都是透明的，不能要求中间件(对二者)提供特殊的支持。如果某人想把中间件合并到应用中，只需要把中间件组件提供给服务器，就好像它是个应用；并且配置好中间件，由它来调用应用，就好像它是个服务器。当前，这个中间件包裹的”应用”也可能是另一个的中间件包裹的另一个应用，等等……(于是)创建出了一个<code>中间件栈</code>(middleware stack)。</p>
<p>大部分情况下，中间件要符合WSGI服务器和WSGI应用的限制和要求。然而，在某些情况下，对于中间件的要求要比纯粹的服务器或者应用要严格得多，这些情况会在本文的后面指出。</p>
<p>下面是一个使用了<code>Joe Strout&#39;s piglatin.py</code>的不太严谨的(tongue-in-cheek)例子：中间件组件把<code>text/plain</code>内容的响应由英文语式转换为拉丁语式(pig Latin)。(注意：真正的中间件会使用更鲁棒的方法来检查内容的类型，并会检查内容编码。同时，这个简单的例子忽略了一个单词可能会跨块边界(block boundary)进行切分的情况。)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">from piglatin import piglatin</span><br><span class="line"></span><br><span class="line">class LatinIter:</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Transform iterated output to piglatin, if it&#x27;s okay to do so</span><br><span class="line"></span><br><span class="line">    Note that the &quot;okayness&quot; can change until the application yields</span><br><span class="line">    its first non-empty string, so &#x27;transform_ok&#x27; has to be a mutable</span><br><span class="line">    truth value.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, result, transform_ok):</span><br><span class="line">        if hasattr(result, &#x27;close&#x27;):</span><br><span class="line">            self.close = result.close</span><br><span class="line">        self._next = iter(result).next</span><br><span class="line">        self.transform_ok = transform_ok</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def next(self):</span><br><span class="line">        if self.transform_ok:</span><br><span class="line">            return piglatin(self._next())</span><br><span class="line">        else:</span><br><span class="line">            return self._next()</span><br><span class="line">            </span><br><span class="line">class Latinator:</span><br><span class="line"></span><br><span class="line">    # by default, don&#x27;t transform output</span><br><span class="line">    transform = False</span><br><span class="line"></span><br><span class="line">    def __init__(self, application):</span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    def __call__(self, environ, start_response):</span><br><span class="line"></span><br><span class="line">        transform_ok = []</span><br><span class="line"></span><br><span class="line">        def start_latin(status, response_headers, exc_info=None):</span><br><span class="line"></span><br><span class="line">            # Reset ok flag, in case this is a repeat call</span><br><span class="line">            del transform_ok[:]</span><br><span class="line"></span><br><span class="line">            for name, value in response_headers:</span><br><span class="line">                if name.lower() == &#x27;content-type&#x27; and value == &#x27;text/plain&#x27;:</span><br><span class="line">                    transform_ok.append(True)</span><br><span class="line">                    # Strip content-length if present, else it&#x27;ll be wrong</span><br><span class="line">                    response_headers = [(name, value)</span><br><span class="line">                        for name, value in response_headers</span><br><span class="line">                            if name.lower() != &#x27;content-length&#x27;</span><br><span class="line">                    ]</span><br><span class="line">                    break</span><br><span class="line">                    </span><br><span class="line">             write = start_response(status, response_headers, exc_info)</span><br><span class="line"></span><br><span class="line">            if transform_ok:</span><br><span class="line">                def write_latin(data):</span><br><span class="line">                    write(piglatin(data))</span><br><span class="line">                return write_latin</span><br><span class="line">            else:</span><br><span class="line">                return write</span><br><span class="line"></span><br><span class="line">        return LatinIter(self.application(environ, start_latin), transform_ok)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run foo_app under a Latinator&#x27;s control, using the example CGI gateway</span><br><span class="line">from foo_app import foo_app</span><br><span class="line">run_with_cgi(Latinator(foo_app))</span><br></pre></td></tr></table></figure>

<h2 id="规范细节-Specification-Details"><a href="#规范细节-Specification-Details" class="headerlink" title="规范细节(Specification Details)"></a><a id="specification-details">规范细节(Specification Details)</a></h2><p>应用必须接收两个可选参数。为了方便叙述，我们把这两个参数分别命名为<code>environ</code>和<code>start_response</code>,但它们不需要一定要叫这个名字。服务器或者网关必须使用位置(而不是关键字)参数来调用应用对象(例如，调用<code>result = application(environ, start_response)</code>)。</p>
<p><code>environ</code>参数是个dict对象，包含了<code>CGI风格</code>(CGI-style)的环境变量。该对象必须是Python内置的字典(而不能是subclass、UserDict及其它的类字典结构)，并且应用要能根据需要以任何方式修改该dict。该dict必须包含WSGI要求的一些变量(后文会叙述)，也可能要包含服务器指定的拓展变量，根据惯例，这些变量会在下文列出。</p>
<p><code>start_response</code>是个接收两个位置参数、一个可选参数的可调用函数。为了方便阐述，我们把这些参数分别命名为<code>status</code>、 <code>response_headers</code>、 <code>exc_info</code>，但它们不必一定要取这样的名字。应用一定要使用位置参数来调用<code>start_response</code>(比如,<code>start_response(status, response_headers)</code>)。</p>
<p><code>status</code>参数是个<code>999 Message here</code>形式的状态字符串，而response_headers是一个描述HTTP响应头的元组(格式：(header_name, header_value))列表。<code>exc_info</code>参数将会在<a href="#the-start-response-callable">The start_response() Callable</a>和<a href="#error-handling">Error Handling</a>部分介绍。只有当应用捕获了异常并向浏览器展示异常信息的时候，才会被使用。</p>
<p><code>start_response</code>一定要返回一个接收一个位置参数的<code>write(body_data)</code>：该参数是个string，表示要写入HTTP响应体中的内容。(注意：<code>write()</code>函数只用于对某些已有的框架提供必要的输出支持，如果能不用，就不要在新的框架中使用，查阅<a href="#buffering-and-streaming">Buffering and Streaming</a>以获取更多详情。)</p>
<p>当被服务器调用时，应用对象必须返回一个包含0个或多个字符串的可迭代的对象。可以通过多种方式实现，比如返回字符串列表，或者让应用对象变成能够yield字符串的生成器，或者让应用变成一个实例可迭代的类。无论如何实现，应用对象必须返回一个包含0个或多个字符串的可迭代的对象。</p>
<p>服务器或者网关一定要以unbuffered的方式向客户端传输生成的字符串，在新的请求到来之前完成传输。(换言之，应用自行处理缓冲；查看<a href="#buffering-and-streaming">Buffering and Streaming</a>部分查看应用的输出如何处理)</p>
<p>服务器或者网关应该将产生的字符串作为字节序列处理：尤其是，不能替换行结束符。应用要保证字符串是以合适的方式传给客户端的。(为了实现字节范围(byte-range)之类的HTTP特性，服务器或者网关可能会做一下HTTP编码转换或者其它转换。查看后文的<a href="#other-http-features">Other HTTP Features</a>部分以获取更多内容)。</p>
<p>如果能成功调用<code>len(iterable)</code>，服务器一定可以信任(这个)准确的结果。即：如果应用返回的iterable对象实现了准确的<code>__len__()</code>，它一定返回了一个准确的结果；查看<a href="#handling-the-content-length-header">Handling the Content-Length Header</a>部分来查询更多信息。)</p>
<p>如果应用返回的可迭代对象有个<code>close()</code>方法，在完成当前请求时，无论请求是正常完成还是因为错误而提前终止，服务器或者网关一定要调用该方法(这是为了释放应用占用的资源)。该协议是为了补充<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0325/">PEP 325</a>的生成器支持以及其它通用的带有<code>close()</code>的可迭代对象。</p>
<p>(注意：在可迭代对象返回它的第一个body字符串之前，应用<strong>一定要</strong>调用start_response()，这样，服务器才能在发送响应体之前发送响应头。然而，该调用也能是由可迭代对象的第一次迭代执行的，所以服务器在开始迭代可迭代对象之前<strong>一定不能</strong>假设：<code>start_response()</code>已经被调用了)</p>
<p>最后强调，服务器和网关<strong>一定不能</strong>直接使用应用返回的可迭代对象的任何其它属性，除非该对象是针对于服务器、网关的特定类型的实例，比如<code>wsgi.file_wrapper</code>返回的<code>file wrapper</code>(参阅<a href="#optional-platform-specific-file-handling">Optional Platform-Specific File Handling</a>部分)，通常情况下，只能访问在这里指定的的属性、或者通过<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0234">PEP 234</a>中定义的的迭代API访问。</p>
<h3 id="environ-变量-environ-Variables"><a href="#environ-变量-environ-Variables" class="headerlink" title="environ 变量(environ Variables)"></a><a id="environ-variables">environ 变量(environ Variables)</a></h3><p><code>environ</code>字典要能包含那些由通用网关接口(Common Gateway Interface)规范定义的<code>CGI</code>环境变量。下列变量一定要是存在的，除非它们的值是空字符串，这种情况下，除非下面特别指出，否则可以被省略。</p>
<p><code>REQUEST_METHOD</code></p>
<blockquote>
<p>HTTP请求方法，如“GET”或者”POST”.该变量是必须的，一定不能是空串。</p>
</blockquote>
<p><code>SCRIPT_NAME</code></p>
<blockquote>
<p>与应用对象对应的请求URL的“路径”的初始部分，这样应用能够获知自己的虚拟位置(virtual “location”)。如果应用在服务器的跟路径的话，该变量的值<strong>可以</strong>是空字符串。</p>
</blockquote>
<p><code>PATH_INFO</code></p>
<blockquote>
<p>请求URL的“路径”的其余部分，指定请求的目标对象在应用内部的虚拟位置。如果请求的是应用的根路径并且URL不带结尾’/‘的话，该变量的值<strong>可以</strong>是空字符串。</p>
</blockquote>
<p><code>QUERY_STRING</code><br>请求的URL中，’?’之后的部分。可能为空或不存在。</p>
<p><code>CONTENT_TYPE</code></p>
<blockquote>
<p>HTTP请求中的Content-Type字段的内容。可能为空或不存在。</p>
</blockquote>
<p><code>CONTENT_LENGTH</code></p>
<blockquote>
<p>HTTP请求中Content-Length字段的内容。可能为空或不存在。</p>
</blockquote>
<p><code>SERVER_NAME , SERVER_PORT</code></p>
<blockquote>
<p>与SCRIPT_NAME和PATH_INFO组合使用时，这两个变量可用于拼接网址。但请注意，如果存在HTTP_HOST，则应优先使用HTTP_SERV而不是ER_NAME来重建请求URL。查看后面的<a href="#url-reconstruction">URL Reconstruction</a>来获取更多详情。SERVER_NAME和SERVER_PORT永远不能是空字符串，因此始终是必需的。</p>
</blockquote>
<p><code>SERVER_PROTOCOL</code></p>
<blockquote>
<p>客户端用于发送请求的协议版本。<br>通常，这将是类似“HTTP/1.0”或“HTTP/1.1”之类的东西，并且供应用用来确定如何处理HTTP请求头。(该变量应该被称为REQUEST_PROTOCOL，因为它表示请求中使用的协议，而不一定是将在服务器响应中使用的协议。<br>但是，为了与CGI保持兼容，我们必须继续使用现有的名称。)</p>
</blockquote>
<p><code>HTTP_ 变量</code></p>
<blockquote>
<p>与客户端提供的HTTP请求头对应的变量(例如，名字以”HTTP_”开头的变量)。这些变量的有/无应该和请求头的有/无一致。</p>
</blockquote>
<p>服务器或网关应尝试提供尽可能多的其他CGI变量。此外，如果启用了SSL，服务器或者网关也要提供尽可能多的 Apache SSL环境变量，比如：HTTPS=on、 SSL_PROTOCOL。<br>然而，请注意，使用了除上面列出的CGI变量之外的任何CGI变量的应用程序是不能移植到不支持相关扩展的Web服务器上的。(<br>例如，不支持发布文件的Web服务器无法提供有意义的DOCUMENT_ROOT或PATH_TRANSLATED。)</p>
<p>符合WSGI规范的服务器或网关应对它们提供的变量及其定义做出文档说明。应用程序应检查是否存在所需的所有变量，并在缺少此类变量的情况下具有后备计划。</p>
<p>注意：缺失的变量(例如，当没有发生认证时，REMOTE_USER会缺失)不应该出现在`environ``字典中。还要注意，CGI变量存在的情况下，值都是字符串。CGI变量的值是str之外的其它类型时，就破坏了本规范。</p>
<p>除了CGI定义的变量之外，environ字典还可以包含任意操作系统的“环境变量”，并且必须包含以下WSGI定义的变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>wsgi.version</td>
<td>tuple(1, 0)，表示WSGI的版本是1.0</td>
</tr>
<tr>
<td>wsgi.url_scheme</td>
<td>字符串，表示正在被请求的应用程序URL的“scheme”部分。</td>
</tr>
<tr>
<td>wsgi.input</td>
<td>一个可以从中读取HTTP请求body的输入流(类似文件对象)。(服务器或网关可以根据应用的请求执行按需读取，或者它可以预先读取客户端的请求body并将其缓存在存储器中或磁盘上，或者使用任何其他技术来提供这样的输入流，根据其偏好。)</td>
</tr>
<tr>
<td>wsgi.errors</td>
<td>一个可以写入错误输出的输出流(文件状对象)，用于在标准化和可能集中的位置记录程序或其他错误。应该是一个“文本模式(text-mode)”流;例如，应用程序应使用“\n”作为行尾，并假设它将由服务器/网关转换为结束的正确行尾。对于许多服务器，<code>wsgi.errors</code>将是服务器的主要错误日志。或者，这可以是<code>sys.stder</code>，或某种类型的日志文件。服务器的文档应包括如何配置或在哪里找到记录的被记录的输出。如果需要，服务器或网关可以向不同的应用提供不同的错误流。</td>
</tr>
<tr>
<td>wsgi.multithread</td>
<td>如果应用程序对象可能被同一进程中的另一个线程同时调用，则此值应为true，否则应为false。</td>
</tr>
<tr>
<td>wsgi.multiprocess</td>
<td>如果一个等效的(<code>equivalent</code>)应用对象可能被另一个进程同时调用，那么该值应该为true，否则应为false。</td>
</tr>
<tr>
<td>wsgi.run_once</td>
<td>如果服务器或网关期望(但不能保证！)应用程序在包含它的进程的生命周期内只被调用一次，则该值应该为true。通常，这将仅适用于基于CGI(或类似的)的网关。</td>
</tr>
</tbody></table>
<p>最后，<code>environ</code>字典还可以包含服务器定义的变量。这些变量应仅使用小写字母，数字，点和下划线命名，并且应使用定义服务器或网关的唯一名称作为前缀。例如，<code>mod_python</code>可以定义名称为<code>mod_python.some_variable</code>的变量。</p>
<h4 id="输入流和错误流-Input-and-Error-Streams"><a href="#输入流和错误流-Input-and-Error-Streams" class="headerlink" title="输入流和错误流(Input and Error Streams)"></a><a id="input-and-error-streams">输入流和错误流(Input and Error Streams)</a></h4><p>服务器提供的输入流和错误流必须支持以下方法：</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Stream</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>read(size)</td>
<td>input</td>
<td>1</td>
</tr>
<tr>
<td>readline()</td>
<td>input</td>
<td>1, 2</td>
</tr>
<tr>
<td>readlines(hint)    input</td>
<td>1, 3</td>
<td></td>
</tr>
<tr>
<td><strong>iter</strong>()</td>
<td>input</td>
<td></td>
</tr>
<tr>
<td>flush()</td>
<td>errors</td>
<td>4</td>
</tr>
<tr>
<td>write(str)</td>
<td>errors</td>
<td></td>
</tr>
<tr>
<td>writelines(seq)</td>
<td>errors</td>
<td></td>
</tr>
</tbody></table>
<p>除了上表中列出的注意项，每个方法的语义都在Python Library Reference中说明了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 服务器不需要读取超过客户端指定的Content-Length的长度，</span><br><span class="line">并且如果应用程序尝试读取长度超过该值的数据时，</span><br><span class="line">则允许服务器模拟文件结束条件。</span><br><span class="line">应用程序不应尝试读取超过CONTENT_LENGTH变量指定的数据。</span><br><span class="line">2. 不支持readline()的可选&quot;size&quot;参数，因为它对于服务器作者来说可能很复杂，并且实际上并不经常使用。</span><br><span class="line">3. 请注意，readlines()的hint参数对于调用者和实现者都是可选的。应用程序可以不支持太参数，服务器或网关可以忽略它。</span><br><span class="line">4. 由于错误流可能没有倒回，服务器和网关可以立即转发写操作而无需缓冲。在这种情况下，flush()方法可以是个停止操作指令</span><br><span class="line">(no-op)。然而，可移植的应用不能假设输出被没有缓冲或flush()是停止操作的指令</span><br><span class="line">。如果他们需要确保输出事实上已经写入，</span><br><span class="line">他们必须调用flush()。(</span><br><span class="line">例如，将自多个进程、写入相同错误日志的混合数据最小化。)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上表中列出的方法必须被遵守本规范的所有服务器支持。符合本规范的应用不得使用<code>input</code>或<code>errors</code>对象的任何其他方法或属性。特别是，应用程序不得尝试关闭这些流，即使这些流拥有close()方法。</p>
<h3 id="可调用的start-response-The-start-response-Callable"><a href="#可调用的start-response-The-start-response-Callable" class="headerlink" title="可调用的start_response()(The start_response() Callable)"></a><a id="the-start-response-callable">可调用的start_response()(The start_response() Callable)</a></h3><p>传递给应用程序的第二个参数是形式为<code>start_response(status，response_headers，exc_info = None)</code>的可调用对象。(与所有WSGI可调用对象一样，必须是位置参数而不能是关键字参数。)<code>start_response</code>可调用对象用于开始HTTP响应，并且必须返回一个<code>write(body_data)</code>可调用对象(查看后文的<a href="#buffering-and-streaming">Buffering and Streaming</a>章节)。</p>
<p><code>status</code>参数是一个HTTP”status”字符串，例如”200 OK”或”04 Not Found”。也就是说，它是由状态码( Status-Code)和原因语句(Reason-Phrase)组成的字符串，按照该顺序并由单个空格分隔，没有周围的空格或其他字符。(查看<a target="_blank" rel="noopener" href="http://www.faqs.org/rfcs/rfc2616.html">RFC 2616</a>的6.1.1节以获取更多信息。)<br>该字符串<strong>一定不能</strong>包含控制字符，并且不能使用回车符、换行符或其组合来终止。</p>
<p><code>response_headers</code>参数是一个由(header_name, header_value)元组元素组成的列表。它一定是一个Python list，即：<code>type(response_headers)是list类型</code>，如果需要，服务器可以以任何方式修改它的内容。每一个<code>header_name</code>一定是一个有效的HTTP头域名(<a target="_blank" rel="noopener" href="http://www.faqs.org/rfcs/rfc2616.html"> RFC 2616</a>4.2节中定义)，不包含结尾的冒号或其他标点符号。</p>
<p>每个<code>header_value</code><strong>一定不能</strong>包含任何嵌入的或结尾处的控制字符，包括回车或换行。(这些要求是为了使必须由要检查、修改响应头的服务器，网关和中间响应处理器执行的解析复杂性最小化。)</p>
<p>一般来说，服务器或网关负责确保向客户端发送正确的头：如果应用程序省略了HTTP(或有效的其他相关规范)所需的标头，则服务器或网关必须添加它。例如，HTTP <code>Date:：</code>和<code>Server:</code>头通常由服务器或网关提供。</p>
<p>(对服务器/网关作者的提醒：HTTP头名称不区分大小写，因此在检查应用程序提供的头时，请务必考虑这一点！)</p>
<p>应用程序和中间件不允许使用HTTP / 1.1“逐跳(hop-by-hop)”特性或headers、HTTP / 1.0中的任何等效功能、或任何影响客户端与Web服务器连接的持久性的headers。这些功能是真实Web服务器的专属，服务器或网关应考虑将应用程序尝试发送它们的视为一个致命错误，如果有异常参数的话，就在start_response()里面抛出异常。(关于<code>hop-by-hop</code>更多规定，查看后文的<a href="#other-http-features">Other HTTP Features</a>)</p>
<p><code>start_response</code>实际上<strong>一定不能</strong>传输响应头。相反，它必须为服务器或网关存储它们，以便仅在应用的返回值第一次迭代产生一个非空的字符串之后、或在应用首次调用write()时，才可以传输。换句话说，不应发送响应头，直到有实际的响应body数据产生、或者直到应用程序返回的可迭代消耗完。(此规则的唯一可能的例外是如果响应头显式地包括Content-Length为0.)</p>
<p>响应头的延迟传输是为了确保缓冲和异步应用直到最后可能的时刻也可以用错误输出来替换它们原来预期的输出。例如，当响应内容正在应用内部缓冲生成时，产生了一个错误，则应用可能需要将响应状态从“200 OK”改变为“500  Internal Error”。</p>
<p><code>exc_info</code>参数(如果提供的话)必须是Python<code>sys.exc_info()</code>元组。当<code>start_response</code>被一个错误处理器调用时，应用必须提供该参数。如果提供了<code>exc_info</code>、还没有HTTP头输出出来，<code>start_response</code>必须使用新提供的响应头替换当前存储的HTTP响应头，此举才能允许应用在错误发生时，能够”改弦易张”(change its mind)。</p>
<p>然而，如果提供了<code>exc_info</code>但是HTTP头已经发送出去了，<code>start_response</code>必须抛出一个<code>exc_info</code>元组异常，如下：</p>
<pre><code>raise exc_info[0], exc_info[1], exc_info[2]
</code></pre>
<p>这会将应用捕获的异常重新抛出，原则上应该中断应用运行。(一旦HTTP头已经被发送，应用程序尝试向浏览器输出错误是不安全的。)如果应用调用<code>start_response</code>时，传入了<code>exc_info</code>参数，那么应用<strong>一定不要</strong>去捕获<code>start_response</code>抛出的任何异常。相反，它应该允许这样的异常传递给服务器或者网关，查阅后文的<a href="#error-handling">Error Handling</a>，以获取更多细节。</p>
<p>当且仅当<code>exc_info</code>参数被提供的时候，应用才可能多次调用<code>start_response</code>。更准确的说法是，如<code>start_response</code>已经在调用应用的过程中被调用了一次，那么果不带<code>exc_info</code>参数再次调用，就是个严重的错误。(有关正确逻辑的说明，请参见上述示例CGI网关。)</p>
<p>注意：实现start_response的服务器，网关或中间件<strong>应</strong>确保在函数执行周期之外没有对exc_info参数进行引用，以避免通过跟踪和相关帧(frame)创建循环引用。简单实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def start_response(status, response_headers, exc_info=None):</span><br><span class="line">    if exc_info:</span><br><span class="line">         try:</span><br><span class="line">             # do stuff w/exc_info here</span><br><span class="line">         finally:</span><br><span class="line">             exc_info = None    # Avoid circular ref.</span><br></pre></td></tr></table></figure>

<p>示例CGI网关提供了此技术的另一个说明。</p>
<h4 id="处理Content-Length-Handling-the-Content-Length-Header"><a href="#处理Content-Length-Handling-the-Content-Length-Header" class="headerlink" title="处理Content-Length(Handling the Content-Length Header)"></a><a id="handling-the-content-length-header">处理Content-Length(Handling the Content-Length Header)</a></h4><p>如果应用不提供<code>Content-Length</code>头部，则服务器或网关可以选择几种方法中的一种来处理它。最简单的方法是在响应完成时关闭客户端连接。</p>
<p>然而在一些情况下，服务器或网关可以能够生成Content-Length报头，或者至少避免关闭客户端连接。如果应用程序没有调用<code>write()</code>并返回了<code>len()</code>为1的迭代器，那么服务器可以通过获取由迭代器产生的第一个字符串的长度自动确定Content-Length。</p>
<p>此外，如果服务器和客户端都支持HTTP 1.1的 “chunked encoding”[3], 那么对于每一次的<code>write()</code>调用或者可迭代对象产生的字符串，服务器可以使用分块编码来发送数据块，这样就为每个数据块生成了一个Content-Length头。这就允许服务器和客户端之间保持有效的连接，如果服务器愿意的话。注意：执行这样的操作时，服务器一定要完全遵守<a target="_blank" rel="noopener" href="http://www.faqs.org/rfcs/rfc2616.html">RFC 2616</a>,否则<br>要回到用于处理Content-Length不存在的其它策略。</p>
<p>(注意：应用程序和中间件不得对其输出应用任何类型的传输编码(<code>Transfer-Encoding</code>), 比如chunking和gzipping；对于“逐跳”操作，这些编码是由实际的web服务器/网关的负责的。查阅后文的<a href="#other-http-features">Other HTTP Features</a>来获取更多细节。)</p>
<h3 id="缓冲和流-Buffering-and-Streaming"><a href="#缓冲和流-Buffering-and-Streaming" class="headerlink" title="缓冲和流(Buffering and Streaming)"></a><a id="buffering-and-streaming">缓冲和流(Buffering and Streaming)</a></h3><p>一般来说，应用程序通过缓冲其(适度大小的)输出并一次性发送输出将实现最佳的吞吐量。对于已有的框架而言，这是一种常见的方式，比如Zope:输出被缓冲在StringIO或类似的对象中，然后连同响应头一起传输。</p>
<p>对于WSGI中的应用程序来说，相应的方法是简单地返回一个包含响应字符串的单个可迭代对象(比如list).<br>这是绝大多数渲染页面的应用函数的推荐方法。</p>
<p>然而，对于大文件或者有着特殊用途的HTTP流(比如multipart “server push”)，应用需要以小块的方式返回输出(避免把大块数据加载到内存中)。也有些生成响应内容非常耗时但先返回部分数据很有意义的情况。</p>
<p>在这些情况下，应用程序通常会返回一个以块为单位的方式生成输出的迭代器(通常是一个生成器迭代器)。这些块可以被分割以与多部分边界(对于“server push”)一致，或者恰好在耗时的任务(例如读取磁盘文件的另一块)之前。</p>
<p>WSGI服务器，网关和中间件<strong>不得</strong>延迟任何块的传输;它们必须将块完全传输到客户端，或者保证即使在应用程序产生其下一个块时它们也将继续传输。<br>服务器/网关或中间件可以通过以下三种方式之一提供此保证：</p>
<ol>
<li>在将控制返回给应用之前，将整个块发送到操作系统(并请求刷新所有O/S缓冲区)</li>
<li>或者使用不同的线程以确保在应用程序生成下一个块时继续传输块。</li>
<li>(仅中间件)将整个块发送到其上层网关/服务器</li>
</ol>
<p>通过提供此保证，WSGI允许应用程序确保传输不会在其输出数据中的任意点停止。这对于合理的处理例如多部分“server push”流(其中多部分边界之间的数据应该被完整地传送到客户端)非常关键。</p>
<h4 id="中间件对块边界的处理-Middleware-Handling-of-Block-Boundaries"><a href="#中间件对块边界的处理-Middleware-Handling-of-Block-Boundaries" class="headerlink" title="中间件对块边界的处理(Middleware Handling of Block Boundaries)"></a><a id="middleware-handling-of-block-boundaries">中间件对块边界的处理(Middleware Handling of Block Boundaries)</a></h4><p>为了更好地支持异步应用程序和服务器，在等待应用返回迭代器生成的多个值时，中间件组件不能阻塞迭代。如果中间件需要在应用生成任何输出之前累积更多数据，它必须产生一个空字符串。</p>
<p>换言之，每次底层的应用产生一个值时，中间件组件必须要产生至少一个值。如果中间件不能产生任何其他值，它必须产生一个空字符串。</p>
<p>此要求确保异步应用和服务器可以共同减少同时运行给定数量的应用实例所需的线程数。</p>
<p>还要注意，该要求意味着只要底层的应用返回了一个可迭代的对象，中间件一定要返回一个可迭代对象。禁止中间件使用write()来传输底层应用产生的数据。中间件只能使用上层服务器的write()来传输底层应用使用中间件提供的write()产生的数据。</p>
<h4 id="可调用的write-The-write-Callable"><a href="#可调用的write-The-write-Callable" class="headerlink" title="可调用的write()(The write() Callable)"></a><a id="the-write-callable">可调用的write()(The write() Callable)</a></h4><p>一些现有的应用程序框架API以不同于WSGI的方式支持非缓冲输出。具体而言，它们提供某种类型的“写入”函数或方法来写入无缓冲的数据块，或者它们提供缓冲的“写入”函数和“刷新”机制来刷新缓冲器。</p>
<p>遗憾的是，除非使用线程或其他特殊机制，否则这些API不能以WSGI的“可迭代”应用返回值来实现。</p>
<p>因此，为了允许这些框架继续使用命令式API，WSGI包括一个特殊的write()，由start_response返回。</p>
<p>如果能避免，新的WSGI应用程序和框架不应该使用write()。write()是一个支持命令式流API的严格的hack。<br>一般来说，应用程序应该通过返回的迭代产生它们的输出，因为这使得Web服务器可以在同一个Python线程中处理其他任务，从而为整个服务器提供更好的吞吐量。</p>
<p>write()由start_response()返回，接受单个参数：一个要作为HTTP响应正文的一部分的被写入的字符串，该字符串被视为由可迭代的输出对象产生。换句话说，在write()返回之前，它必须保证传入的字符串被完全发送到客户端，或者它被缓冲用于传输，而应用程序继续执行。</p>
<p>应用程序必须返回一个可迭代对象，即使它使用write()产生其全部或部分响应体。返回的可迭代结果可以是空的(即，没有产生非空字符串)，但是如果它产生非空字符串，则该输出必须由服务器或网关正常处理(即，必须立即发送或排队)。应用程序不能在它们的可迭代结果调用write()，因此迭代器产生的任何字符串在传递给write()的所有字符串都被发送到客户端之后被传输。</p>
<h3 id="Unicode问题-Unicode-Issues"><a href="#Unicode问题-Unicode-Issues" class="headerlink" title="Unicode问题(Unicode Issues)"></a><a id="unicode-issues">Unicode问题(Unicode Issues)</a></h3><p>HTTP并不直接支持Unicode，WSGI也不会。所有的编码和解码都由应用去执行；从服务器收到或者发给服务器的字符串都必须是标准的Python字节字符串，不能是Unicode对象。在要使用字符串的是地方使用了Unicode对象，结果是未定义的。</p>
<p>注意，传给start_response()、作为状态或者响应头的字符串必须符合<a target="_blank" rel="noopener" href="http://www.faqs.org/rfcs/rfc2616.html">RFC 2616</a>指定的编码。必须是ISO-8859-1或者[RFC 2047]规定的MIME编码。</p>
<p>在Python平台，str或者StringType类型都是基于Unicode的(如ython, IronPython, Python 3000等)，本规范提到的所有的字符串只能包含代表ISO-8859-1编码的code point(包含 \u0000 ~ \u00FF )。如果应用提供了包含其它unicode字符或者code point，将是严重的错误。同理，服务器和网关一定不要向应用提供其它的unicode字符。</p>
<p>再次强调，本规范提到的所有字符串一定是str或者StringType类型，一定不能是unicode或者UnicodeType类型。且，即使给定平台在str / StringType对象中允许每个字符多于8位，对于本说明书中称为“字符串”的任何值也可以仅使用低8位。</p>
<h3 id="错误处理-Error-Handling"><a href="#错误处理-Error-Handling" class="headerlink" title="错误处理(Error Handling)"></a><a id="error-handling">错误处理(Error Handling)</a></h3><p>一般来说，应用程序应该尝试捕获自己的内部错误，并在浏览器中显示有用的消息。(由应用自行决定，在具体的上下文中什么才是”有用的”)</p>
<p>然而，为了显示这样的消息，应用程序必须实际上还没有向浏览器发送任何数据，否则会有损坏响应的风险。因此，WSGI提供了一种机制，允许应用发送错误消息，或者自动中止：传给start_response的exc_info参数。下面是一个使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    # regular application code here</span><br><span class="line">    status = &quot;200 Froody&quot;</span><br><span class="line">    response_headers = [(&quot;content-type&quot;, &quot;text/plain&quot;)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    return [&quot;normal body goes here&quot;]</span><br><span class="line">except:</span><br><span class="line">    # XXX should trap runtime issues like MemoryError, KeyboardInterrupt</span><br><span class="line">    #     in a separate handler before this bare &#x27;except:&#x27;...</span><br><span class="line">    status = &quot;500 Oops&quot;</span><br><span class="line">    response_headers = [(&quot;content-type&quot;, &quot;text/plain&quot;)]</span><br><span class="line">    start_response(status, response_headers, sys.exc_info())</span><br><span class="line">    return [&quot;error body goes here&quot;]</span><br></pre></td></tr></table></figure>

<p>如果在发生异常时没有写入输出，则对start_response的调用将正常返回，应用将返回错误主体以发送到浏览器。但是，如果有任何输出已经发送到浏览器，start_response将重新抛出所提供的异常。此异常不应该被应用捕获，因此应用将中止。然后，服务器或网关可以捕获此(严重的)异常并中止响应。</p>
<p>服务器应该捕获并记录中断应用或应用返回值迭代的任何异常。如果在发生应用错误时已经将部分响应写入浏览器，如果已经发送的报头是服务器知道如何完全修改的text/* 内容类型，则服务器或网关可以尝试向输出添加错误消息。</p>
<p>一些中间件可能希望提供额外的异常处理服务，或拦截和替换应用程序错误消息。在这种情况下，中间件可以选择不重新抛出传给start_response的exc_info，而是抛出中间件的特定的异常，或在存储参数后，不返回异常。这将导致应用返回可迭代的错误主体(或调用write())，允许中间件捕获和修改错误输出。这些技术将生效，只要应用作者：</p>
<ol>
<li>开始错误响应时，始终提供exc_info</li>
<li>提供exc_info时，从不捕获由start_response引发的错误。</li>
</ol>
<h3 id="HTTP-1-1期望-继续-HTTP-1-1-Expect-Continue"><a href="#HTTP-1-1期望-继续-HTTP-1-1-Expect-Continue" class="headerlink" title="HTTP 1.1期望/继续(HTTP 1.1 Expect/Continue)"></a><a id="http-1-1-expect-continue">HTTP 1.1期望/继续(HTTP 1.1 Expect/Continue)</a></h3><p>实现HTTP 1.1的服务器和网关必须为HTTP 1.1的“期望/继续”机制提供透明支持。这可以以几种方式中的任何一种来完成：</p>
<ol>
<li>对于包含<code>Expect: 100-continue</code>的请求，要立即返回一个包含 “100 Continue”的响应，然后正常执行</li>
<li>正常继续请求，但为应用程序提供一个wsgi.input流，如果/当应用程序首次尝试从输入流读取时，将发送“100 Continue”响应。然后，读取请求必须保持阻塞，直到客户端响应。</li>
<li>等待，直到客户机决定服务器不支持expect/continue，并且自行发送请求。 (这是次优的，不推荐。)</li>
</ol>
<p>请注意，这些行为限制不适用于HTTP 1.0请求，也不适用于未定向到应用程序对象的请求。查阅<a target="_blank" rel="noopener" href="http://www.faqs.org/rfcs/rfc2616.html">RFC 2616</a>的 8.2.3和10.1.1节，获取HTTP 1.1 Expect/Continue的更多信息。</p>
<h3 id="其它的HTTP特性-Other-HTTP-Features"><a href="#其它的HTTP特性-Other-HTTP-Features" class="headerlink" title="其它的HTTP特性(Other HTTP Features)"></a><a id="other-http-features">其它的HTTP特性(Other HTTP Features)</a></h3><p>一般来说，服务器和网关应该“装聋作哑”，并允许应用程序完全控制其输出。<br>他们只应该进行不会改变应用响应的有效语义的更改。应用开发人员总是可以添加中间件组件来提供额外的功能，因此服务器/网关开发人员应该在实现中保守一点(译者注:不开发过多的功能)。在某种意义上，服务器应该认为自己像HTTP“网关服务器(gateway server)”，应用程序是HTTP“源服务器(origin server)”.(查阅<a target="_blank" rel="noopener" href="http://www.faqs.org/rfcs/rfc2616.html">RFC 2616</a>1.3节，来了解这些术语的定义)。</p>
<p>但是，因为WSGI服务器和应用不通过HTTP进行通信，所以RFC 2616称为“hop-by-hop”报头不适用于WSGI内部通信。WSGI应用不得生成任何“hop-by-hop”头[4]、不能尝试使用将要求它们生成这样的报头的HTTP特性，或者依赖于environ字典中的任何传入的“hop-by-hop”报头的内容。<br>WSGI服务器必须自己处理任何支持的入站“hop-by-hop”报头，例如通过解码任何入站的Transfer-Encoding，包括分块编码( chunked encoding)(如果适用的话)。</p>
<p>将这些原理应用于各种HTTP特性时，应当清楚:服务器可以通过If-None-Match和If-Modified-Since请求头部以及Last-Modified和ETag响应头部来处理缓存验证。然而，不必如此，并且如果应用想要支持该特征，则应该执行它自己的缓存验证，因为服务器/网关不需要进行这样的验证。</p>
<p>类似地，服务器可以对应用的响应进行重新编码或传输编码，但是应用应当使用其自己的合适的内容编码，并且不能应用传输编码。如果客户端请求，服务器可以传送应用的响应的字节范围，并且应用本身不支持该字节范围。但是，如果需要，应用程序应该自行实现此功能。</p>
<p>请注意，对应用程序的这些限制并不一定意味着每个应用程序都必须重新实现每个HTTP功能;许多HTTP特征可以由中间件组件部分或完全实现，从而使服务器和应用作者免于重复实现相同的特性。</p>
<h3 id="线程支持-Thread-Support"><a href="#线程支持-Thread-Support" class="headerlink" title="线程支持(Thread Support)"></a><a id="thread-support">线程支持(Thread Support)</a></h3><p>是否支持多线程依赖于服务器。可以并行运行多个请求的服务器还应该提供以单线程方式运行应用程序的选项，以便不是线程安全的应用程序或框架仍然可以与该服务器一起使用。</p>
<h2 id="lt-a-id-”implementation-application-notes-gt-实现-应用注意事项-Implementation-Application-Notes"><a href="#lt-a-id-”implementation-application-notes-gt-实现-应用注意事项-Implementation-Application-Notes" class="headerlink" title="&lt;a id=”implementation-application-notes&gt;实现/应用注意事项(Implementation/Application Notes)"></a>&lt;a id=”implementation-application-notes&gt;实现/应用注意事项(Implementation/Application Notes)</a></h2><h3 id="服务器拓展APIs-Server-Extension-APIs"><a href="#服务器拓展APIs-Server-Extension-APIs" class="headerlink" title="服务器拓展APIs(Server Extension APIs)"></a><a id="server-extension-apis">服务器拓展APIs(Server Extension APIs)</a></h3><p>一些服务器作者也许想要暴露一些高级的API，满足应用或者框架的作者的特定需要。例如，一个基于mod_python的网关也许想要暴露部分的Apache API作为WSGI的拓展。</p>
<p>在最简单的情形下，只要求定义一个environ变量，比如<code>mod_python.some_api</code>。但是，在多数场合，中间件的存在使得实现起来比较困难。例如，一个提供访问相同HTTP头的API可能存在于environ变量中，但是如果environ被中间件修改了，该API可能会返回不同的数据。</p>
<p>一般而言，任何复制、取代、绕过WSGI部分功能的API运行时都会冒着和中间件组件不兼容的风险。服务器/网关的开发者不能假设没有人会使用中间件，因为一些框架的开发者特意组织或者重构他们的框架，使其几乎完全可以充当各种类型的中间件。</p>
<p>所以，为了提供最大的兼容性，提供了替代部分WSGI功能API的服务器、网关一定要把这些API设计成：当调用他们所要替换的接口时，这些API会被调用。例如，一个访问HTTP请求头的API拓展，一定要要求应用传递自身当前的environ，从而服务器或者网关能够通过这个API验证HTTP头是否被中间件替换了。如果这个拓展API不能保证它总和带有HTTP头内容的environ保持一致，它一定要拒绝为应用服务，即：通过抛出错误、返回None而不是一个HTTP头的集合或者任何该API适合做的。</p>
<p>类似的，如果扩展API提供了写入响应数据或头的替代方法，它应该在应用获得拓展服务之前要求传入start_response。如果传入的对象与服务器/网关最初提供给应用的对象不同，则它不能保证正确的操作，并且必须拒绝向应用提供扩展服务。</p>
<p>这些准则也适用于将诸如解析的cookie，表单变量，会话等信息添加到environ中的中间件。具体来说，这样的中间件应该提供这些功能作为对environ操作的功能，而不是简单地将值填充到environ中。这有助于确保在任何中间件完成任何URL重写或其他environ修改后，从environ中计算出信息。</p>
<p>非常重要的是，这些“安全扩展”规则由服务器/网关和中间件开发者遵循，以便避免将来中间件开发人员被迫从environ中删除任何所有的扩展API，以确保他们的修改(mediation)没被使用这些扩展的应用绕过！</p>
<h3 id="应用配置-Application-Configuration"><a href="#应用配置-Application-Configuration" class="headerlink" title="应用配置(Application Configuration)"></a><a id="application-configuration">应用配置(Application Configuration)</a></h3><p>本规范不对服务器如何去选择或者获得一个要被调用的应用做出定义。配置选项是更高层面的特定于服务器(的规范)要操心的。期望服务器/网关作者将对如何配置服务器以执行特定的应用对象，以及什么选项(如线程选项)做出文档说明。</p>
<p>另一方面，框架作者应该对如何创建一个包裹了框架功能的应用对象作出说明。已经选定服务器和应用程序框架的用户必须将两者结合在一起。然而，由于框架和服务器现在都有一个公共接口，这应该只是一个不费脑的问题，而不是每个新的服务器/框架组合都需要让人累死累活(significant engineering effort)。</p>
<p>最后，一些应用程序，框架和中间件可能希望使用environ字典接收简单的字符串配置选项。服务器和网关应该通过允许应用程序的部署者指定要放置在环境中的”name-value “来支持这一点。在最简单的情况下，这种支持可以仅仅包括将所有操作系统提供的环境变量从os.environ复制到environ字典中，因为部署者原则上可以在服务器外部配置它们，或者在CGI情况下，他们可以通过服务器的配置文件设置。</p>
<p>应用应尽量将此类必需的变量保持最少，因为并非所有服务器都支持容易的配置。当然，即使在最坏的情况下，部署应用程序的人也可以创建一个脚本来提供必要的配置值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from the_app import application</span><br><span class="line"></span><br><span class="line">def new_app(environ, start_response):</span><br><span class="line">    environ[&#x27;the_app.configval1&#x27;] = &#x27;something&#x27;</span><br><span class="line">    return application(environ, start_response)</span><br></pre></td></tr></table></figure>

<p>但是，大多数现有的应用和框架可能只需要一个来自environ的配置值，以指示其应用或框架特定的配置文件的位置。(当然，应用程序应该把这样的配置缓存起来，以避免在每次调用时重新读取它。)</p>
<h3 id="URL重构-URL-Reconstruction"><a href="#URL重构-URL-Reconstruction" class="headerlink" title="URL重构(URL Reconstruction)"></a><a id="url-reconstruction">URL重构(URL Reconstruction)</a></h3><p>如果应用程序希望重构请求的完整URL，则可以使用由Ian Bicking贡献的以下算法来这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">from urllib import quote</span><br><span class="line">url = environ[&#x27;wsgi.url_scheme&#x27;]+&#x27;://&#x27;</span><br><span class="line"></span><br><span class="line">if environ.get(&#x27;HTTP_HOST&#x27;):</span><br><span class="line">    url += environ[&#x27;HTTP_HOST&#x27;]</span><br><span class="line">else:</span><br><span class="line">    url += environ[&#x27;SERVER_NAME&#x27;]</span><br><span class="line"></span><br><span class="line">    if environ[&#x27;wsgi.url_scheme&#x27;] == &#x27;https&#x27;:</span><br><span class="line">        if environ[&#x27;SERVER_PORT&#x27;] != &#x27;443&#x27;:</span><br><span class="line">           url += &#x27;:&#x27; + environ[&#x27;SERVER_PORT&#x27;]</span><br><span class="line">    else:</span><br><span class="line">        if environ[&#x27;SERVER_PORT&#x27;] != &#x27;80&#x27;:</span><br><span class="line">           url += &#x27;:&#x27; + environ[&#x27;SERVER_PORT&#x27;]</span><br><span class="line"></span><br><span class="line">url += quote(environ.get(&#x27;SCRIPT_NAME&#x27;, &#x27;&#x27;))</span><br><span class="line">url += quote(environ.get(&#x27;PATH_INFO&#x27;, &#x27;&#x27;))</span><br><span class="line">if environ.get(&#x27;QUERY_STRING&#x27;):</span><br><span class="line">    url += &#x27;?&#x27; + environ[&#x27;QUERY_STRING&#x27;]</span><br></pre></td></tr></table></figure>

<p>注意，这种重构的URL可能不是与客户端所请求的精确匹配的URI。例如，服务器重写规则可能已修改客户端最初请求的URL以将其转为规范形式。</p>
<h3 id="支持-lt-2-2-老版本的Python-Supporting-Older-lt-2-2-Versions-of-Python"><a href="#支持-lt-2-2-老版本的Python-Supporting-Older-lt-2-2-Versions-of-Python" class="headerlink" title="支持(&lt;2.2)老版本的Python(Supporting Older (&lt;2.2) Versions of Python)"></a><a id="supporting-older-2-2-versions-of-python">支持(&lt;2.2)老版本的Python(Supporting Older (&lt;2.2) Versions of Python)</a></h3><p>一些服务器，网关或应用程序可能希望支持旧(&lt;2.2)版本的Python。如果Jython是目标平台，这一点尤为重要，因为在撰写本文时，Jython 2.2的生产版本尚不可用。</p>
<p>对于服务器和网关，这是相对直接的：针对Python2.2版本之前的服务器和网关必须简单地限制自己只使用一个标准的“for”循环来遍历应用程序返回的任何可迭代对象。这是确保2.2前迭代器协议(下面进一步讨论)和“今天”迭代器协议代码级别兼容的唯一方法。(查阅 <a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0234">PEP 234</a>)</p>
<p>(请注意，此技术仅适用于使用Python编写的服务器，网关或中间件。关于如何从其他语言正确使用迭代器协议的讨论超出了本PEP的范围。)</p>
<p>对于支持Python2.2之前版本的应用稍微复杂一些：</p>
<ol>
<li>你不能返回一个文件对象并期望它可迭代，因为在Python 2.2之前，文件不可迭代。(一般来说，你不应该这样做，因为它将在大多数情形下性能太差).使用wsgi.file_wrapper或特定于应用程序的文件包装类。(查阅<a href="#optional-platform-specific-file-handling">Optional Platform-Specific File Handling</a>获取关于 wsgi.file_wrapper 更多信息，有个类的例子，你可以用于把file包装成一个可迭代的对象)</li>
<li>如果你返回一个自定义的迭代器，它必须实现2.2版本之前的迭代器协议。也就是说，提供一个接受整数键的__getitem__方法，并在迭代完成时引发IndexError。 (注意，内置序列类型也是可以接受的，因为它们也实现这个协议。)</li>
</ol>
<p>最后，希望支持Python2.2之前版本并且遍历应用返回值或自身返回可迭代(或两者)的中间件必须遵循上述适当的建议。</p>
<p>(注意：不用说，为了支持Python的前2.2版本，任何服务器，网关，应用程序或中间件都必须仅使用目标版本中可用的语言特性，使用1和0而不是True和False等。)</p>
<h3 id="可选的特定平台的文件处理-Optional-Platform-Specific-File-Handling"><a href="#可选的特定平台的文件处理-Optional-Platform-Specific-File-Handling" class="headerlink" title="可选的特定平台的文件处理(Optional Platform-Specific File Handling)"></a><a id="optional-platform-specific-file-handling">可选的特定平台的文件处理(Optional Platform-Specific File Handling)</a></h3><p>某些操作环境提供特殊的高性能文件传输功能，如Unix sendfile()调用。服务器和网关可以通过environ中的可选wsgi.file_wrapper键来暴露此功能。<br>应用可以使用此“文件包装器”将文件或类文件对象转换为可迭代的对象，然后返回，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if &#x27;wsgi.file_wrapper&#x27; in environ:</span><br><span class="line">    return environ[&#x27;wsgi.file_wrapper&#x27;](filelike, block_size)</span><br><span class="line">else:</span><br><span class="line">    return iter(lambda: filelike.read(block_size), &#x27;&#x27;)</span><br></pre></td></tr></table></figure>
<p>如果服务器或网关提供wsgi.file_wrapper，它必须是一个接受一个必需的位置参数和一个可选的位置参数的可调用对象。第一个参数是要发送的类文件对象，第二个参数是一个可选的块大小“建议”(服务器/网关不必使用)。<br>可调用对象必须返回一个可迭代对象，并且必须不执行任何数据传输，直到并且除非服务器/网关实际上从应用接收到可一个可迭代对象。(否则将阻止中间件能够解析或覆盖响应数据。)</p>
<p>为了被视为“类文件”，应用提供的对象必须有一个read()方法，该方法接受一个可选的size参数。它可能有一个close()方法，如果有的话，wsgi.file_wrapper返回的iterable必须有一个close()方法，该方法调用原始的类文件对象的close()方法。如果“类文件”对象具有与Python内置文件对象(例如fileno())相同的任何其他方法或属性，则wsgi.file_wrapper可以假定这些方法或属性具有与内置文件对象方法或属性相同的语义。</p>
<p>任何特定平台否文件处理的实现必须在应用返回后发生，并且服务器或网关检查是否返回了包装器对象。 (再次强调，由于存在中间件，错误处理器等，不能保证创建的包装器实际上被使用)。</p>
<p>除了处理close()之外，从应用程序返回文件包装器的语义应该与应用程序返回的iter(filelike.read，’’)相同。换句话说，传输应该在传输开始时在“文件”内的当前位置开始，并且继续直到到达结束。</p>
<p>当然，特定平台的文件传输API通常不接受任意的“类文件”对象。因此，wsgi.file_wrapper必须对诸如fileno()(类Unix的OSes)或java.nio.FileChannel(在Jython下)之类的东西进行内省，以确定类文件对象是否适合于平台特定的API。</p>
<p>请注意，即使对象不适合平台API，wsgi.file_wrapper仍必须返回一个包装read()和close()的迭代器，以便使用文件包装器的应用程序可跨平台移植。这里有一个简单的平台无关文件包装类，适合老(pre 2.2)和新的Pythons：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class FileWrapper:</span><br><span class="line"></span><br><span class="line">    def __init__(self, filelike, blksize=8192):</span><br><span class="line">        self.filelike = filelike</span><br><span class="line">        self.blksize = blksize</span><br><span class="line">        if hasattr(filelike, &#x27;close&#x27;):</span><br><span class="line">            self.close = filelike.close</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        data = self.filelike.read(self.blksize)</span><br><span class="line">        if data:</span><br><span class="line">            return data</span><br><span class="line">        raise IndexError</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>这里有个来自服务器/网关的代码片段，使用它来提供对平台特定的API的访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">environ[&#x27;wsgi.file_wrapper&#x27;] = FileWrapper</span><br><span class="line">result = application(environ, start_response)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    if isinstance(result, FileWrapper):</span><br><span class="line">        # check if result.filelike is usable w/platform-specific</span><br><span class="line">        # API, and if so, use that API to transmit the result.</span><br><span class="line">        # If not, fall through to normal iterable handling</span><br><span class="line">        # loop below.</span><br><span class="line"></span><br><span class="line">    for data in result:</span><br><span class="line">        # etc.</span><br><span class="line"></span><br><span class="line">finally:</span><br><span class="line">    if hasattr(result, &#x27;close&#x27;):</span><br><span class="line">        result.close()</span><br></pre></td></tr></table></figure>

<h2 id="问题和回答-Questions-and-Answers"><a href="#问题和回答-Questions-and-Answers" class="headerlink" title="问题和回答(Questions and Answers)"></a><a href="#questions-and-answers">问题和回答(Questions and Answers)</a></h2><ol>
<li>为什么必须environ是字典？使用子类有什么问题？</li>
</ol>
<blockquote>
<p>使用字典是为了使服务器间的可移植性最大化。<br>替代方法是将字典方法的一些子集定义为标准和可移植接口。<br>然而在实践中，大多数服务器可能会发现字典足以满足他们的需要，<br>因此大多数情况下框架作者会希望使用所有的字典特性。<br>但是，尽管服务器“符合”WSGI规范，如果服务器选择不使用字典，将存在互操作性问题。<br>因此，强制使用字典，可以简化规范并保证互操作性。</p>
</blockquote>
<blockquote>
<p>请注意，这不会阻止服务器或框架开发人员将专门服务作为environ字典中中的自定义变量。<br>这是提供任何此类增值服务的推荐方法。</p>
</blockquote>
<ol start="2">
<li>为什么可以调用write()和yield字符串/返回一个可迭代？难道不应该只选择一种方式吗？</li>
</ol>
<blockquote>
<p>如果我们只支持迭代方法，那么会给当前以“推送”为前提的框架带来麻烦。但是，如果我们只支持通过write()推送，<br>那么服务器性能会受到传输的影响，比如大文件(如果工作线程在所有的输出发送之前不能处理新的请求)。<br>因此，对于服务器实现者而言，这种折衷允许应用程序框架适当地支持这两种方法比仅推送方法将只增加了少许的负担。</p>
</blockquote>
<ol start="3">
<li>close()是干嘛的？</li>
</ol>
<blockquote>
<p>当在执行应用程序对象期间完成写入时，应用程序可以确保使用try/finally块释放资源。<br>但是，如果应用程序返回一个可迭代对象，直到可迭代对象被回收，任何使用的资源才会被释放。<br>close()允许应用在请求结束时释放关键资源，并且它与<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-0325">PEP 325</a><br>提出的生成器中对try/finally的支持前向兼容。</p>
</blockquote>
<ol start="4">
<li>为什么WSGI接口这么低级？我想要更NB的特性！(如Cookie，会话，持久化…)</li>
</ol>
<blockquote>
<p>这不是另一个Python Web框架。它只是一种框架与web服务器互相通信的方式。<br>如果你想要这些(高级)功能，你需要选择一个提供你想要的功能web框架。<br>如果该框架允许您创建WSGI应用，您应该能够在大多数支持WSGI的服务器上运行它。<br>此外，一些WSGI服务器可以通过其environ字典中提供的对象提供附加服务;有关详细信息，请参阅适用的服务器文档。<br>(当然，使用这种扩展的应用将不能移植到其他基于WSGI的服务器。)</p>
</blockquote>
<ol start="5">
<li>为什么使用CGI变量而不是好的旧HTTP头？为什么要将它们与WSGI定义的变量混合？</li>
</ol>
<blockquote>
<p>许多现有的Web框架都是基于CGI规范构建的，现有的Web服务器知道如何生成CGI变量。<br>相比之下，表示入站HTTP信息的替代方法是分散的，并且缺乏市场份额。<br>因此，使用CGI“标准”似乎是利用现有实现的好方法。<br>至于将它们与WSGI变量混合，分离它们需要传递两个字典参数，而没有提供真正的好处。</p>
</blockquote>
<ol start="6">
<li>status字符串呢？不能只使用数字么，传递200而不是“200 OK”？</li>
</ol>
<blockquote>
<p>要求服务器或网关有一个数字状态和相应的消息的映射，会使服务器或网关复杂化。<br>相比之下，应用程序或框架的作者很容易针对他们正在使用的特定响应代码来返回额外的文本，<br>并且现有框架通常已经具有包含所需消息的映射表。<br>所以，权衡之下，使应用程序/框架来负责似乎更好，而不是服务器或网关。</p>
</blockquote>
<ol start="7">
<li>为什么wsgi.run_once不能保证只让应用运行一次？</li>
</ol>
<blockquote>
<p>因为它只是对应用的一个建议：它应该“不频繁地运行”。这适用于具有用于缓存，会话等多种操作模式的应用框架。在“多运行(multiple run)”模式中，这样的框架可以预加载缓存，并且可以不必再在每个请求后把如日志或会话数据等写入磁盘。在“单运行(single run)”模式下，此类框架避免预加载,并在每个请求之后刷新所有必需的写入。</p>
</blockquote>
<blockquote>
<p>然而，为了测试应用或框架能够在后一模式中的正确工作，可能有必要(或至少方便的是)多次调用它。因此，应用程序不应该假设它肯定不会再次运行，哪怕当它被调用时，wsgi.run_once设置为True。</p>
</blockquote>
<ol start="8">
<li>特征X(字典，可调用对象等)在应用代码中写起来很丑陋;为什么我们不使用对象？</li>
</ol>
<blockquote>
<p>WSGI所有实现方案的选择是专门用于将texing间解耦;将这些特征重新组合到封装的对象中使得写服务器或网关变得有些困难，并且更难以写替换或者修改整个功能的一小部分的中间件。</p>
</blockquote>
<blockquote>
<p>实质上，中间件想要的是“责任链”模式，从而它可以作为一些功能的“处理程序”，同时允许其他功能保持不变。如果接口是保持可扩展的话，对于普通PYthon对象就很难处理。例如，必须使用__getattr__或__getattribute__覆盖，以确保扩展(如由未来WSGI版本定义的属性)通过。</p>
</blockquote>
<blockquote>
<p>这种类型的代码很难100％正确，很少有人会想要自己实现。因此，他们将复制其他人的实现，但是当他们所复制的人纠正某个错误时，抄袭的人却不能更新它们。</p>
</blockquote>
<blockquote>
<p>进一步来说，这个必要的强制要求就是一种消费税，只是由中间件的开发者来付费，向应用框架开发者提供轻量级、优雅的的API。但是，应用框架开发人员通常只更新一个框架来支持WSGI，并且改动在整个框中是非常有限的部分。可能是他们的第一个(也许是他们的)WSGI实现，因此他们很可能随时准备实现这个规范。因此，对于这个观众来说，使得具有对象属性的API“更优雅”的努力可能会浪费。</p>
</blockquote>
<blockquote>
<p>我们鼓励那些想直接在Web应用编程(相对于Web框架开发)中使用更优雅(或者改进的)的WSGI接口的人去开发包裹了WSGI的API或者框架供应用开发者方便使用。来开发API或框架，包装WSGI以方便应用程序开发人员使用。这样，WSGI可以为服务器和中间件作者保持方便的低层次接口，而对于应用程序开发人员来说看起来又不“丑陋的”。</p>
</blockquote>
<h2 id="拟议-讨论中-Proposed-Under-Discussion"><a href="#拟议-讨论中-Proposed-Under-Discussion" class="headerlink" title="拟议/讨论中(Proposed/Under Discussion)"></a><a id="proposed-under-discussion">拟议/讨论中(Proposed/Under Discussion)</a></h2><p>这些项目目前正在Web-SIG和其他地方讨论，或者是PEP作者的“待办事项”列表：</p>
<ul>
<li>wsgi.input应该是一个迭代器而不是一个文件？这将有助于异步应用程序和分块编码输入流。</li>
<li>正在讨论可选扩展，用于暂停应用程序输出的迭代，直到输入可用或直到发生回调。</li>
<li>添加一节关于同步应用和服务器v.s.异步应用和服务器、相关的线程模型和这些领域的问题/设计目标的说明。</li>
</ul>
<h2 id="致谢-Acknowledgements"><a href="#致谢-Acknowledgements" class="headerlink" title="致谢(Acknowledgements)"></a><a id="acknowledgements">致谢(Acknowledgements)</a></h2><p>感谢那些周到的反馈使得本修订草案成为可能的Web-SIG邮件列表人员。特别是：</p>
<ul>
<li>Gregory“Grisha”Trubetskoy，mod_python的作者，第一稿比<code>plain old CGI</code>没有任何优势，就被他狠批了，从而鼓励我寻找一个更好的方法。</li>
<li>Ian Bicking，通过”找茬儿”,他帮助我正确地指定了多线程和多进程选项，以及不停地催促我提供一种机制，供服务器给应用提供自定义扩展数据。</li>
<li>Tony Lownds，他想出了一个接收状态和HTTP头的start_response函数概念，该函数返回了一个write函数。他还指导了异常处理的设计，特别是在允许覆盖应用错误消息的中间件领域。</li>
<li>Alan Kennedy勇敢地尝试实现WSGI-on-Jython(在规范完成之前),帮助塑造了“<a href="#supporting-older-2-2-versions-of-python">supporting older versions of Python</a>”部分以及可选的wsgi.file_wrapper工具。</li>
<li>Mark Nottingham，他广泛审查了HTTP RFC合规性的问题，特别是关于HTTP/1.1特性，这些特性我甚至不知道存在，直到他指出来。</li>
</ul>
<h2 id="参考资料-References"><a href="#参考资料-References" class="headerlink" title="参考资料(References)"></a><a id="references">参考资料(References)</a></h2><p>[1]    The Python Wiki “Web Programming” topic (<a target="_blank" rel="noopener" href="http://www.python.org/cgi-bin/moinmoin/WebProgramming">http://www.python.org/cgi-bin/moinmoin/WebProgramming</a>)</p>
<p>[2]    The Common Gateway Interface Specification, v 1.1, 3rd Draft ( <a target="_blank" rel="noopener" href="http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt">http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt</a> )</p>
<p>[3]    “Chunked Transfer Coding” – HTTP/1.1, section 3.6.1 ( <a target="_blank" rel="noopener" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1">http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1</a> )</p>
<p>[4]    “End-to-end and Hop-by-hop Headers” – HTTP/1.1, Section 13.5.1 ( <a target="_blank" rel="noopener" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.5.1">http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.5.1</a> )</p>
<p>[5]    mod_ssl Reference, “Environment Variables” ( <a target="_blank" rel="noopener" href="http://www.modssl.org/docs/2.8/ssl_reference.html#ToC25">http://www.modssl.org/docs/2.8/ssl_reference.html#ToC25</a> )</p>
<h2 id="版权-Copyright"><a href="#版权-Copyright" class="headerlink" title="版权(Copyright)"></a><a id="copyright">版权(Copyright)</a></h2><p>此文档已放在公共领域。</p>
<p>源: <a target="_blank" rel="noopener" href="https://github.com/python/peps/blob/master/pep-0333.txt">https://github.com/python/peps/blob/master/pep-0333.txt</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/WSGI/" rel="tag"># WSGI</a>
          
            <a href="/tags/PEP-333/" rel="tag"># PEP 333</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/19/leetcode-166-Fraction-to-Recurring-Decimal/" rel="next" title="leetcode-166-Fraction to Recurring Decimal">
                <i class="fa fa-chevron-left"></i> leetcode-166-Fraction to Recurring Decimal
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/10/python-web%E5%AF%BC%E5%87%BA%E6%9C%89%E6%8E%92%E7%89%88%E8%A6%81%E6%B1%82%E7%9A%84pdf/" rel="prev" title="python web导出有排版要求的pdf">
                python web导出有排版要求的pdf <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">103</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">139</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E8%A8%80-Preface"><span class="nav-number">1.</span> <span class="nav-text">序言(Preface)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%A6%81-Abstract"><span class="nav-number">2.</span> <span class="nav-text">概要(Abstract)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E8%AF%B4%E6%98%8E%E5%92%8C%E7%9B%AE%E6%A0%87-Rationale-and-Goals"><span class="nav-number">3.</span> <span class="nav-text">理论说明和目标(Rationale and Goals)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%84%E8%8C%83%E6%A6%82%E8%BF%B0-Specification-Overview"><span class="nav-number">4.</span> <span class="nav-text">规范概述(Specification Overview)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8-%E6%A1%86%E6%9E%B6%E7%AB%AF-The-Application-Framework-Side"><span class="nav-number">4.1.</span> <span class="nav-text">应用&#x2F;框架端(The Application&#x2F;Framework Side)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%BD%91%E5%85%B3%E7%AB%AF-The-Server-Gateway-Side"><span class="nav-number">4.2.</span> <span class="nav-text">服务器&#x2F;网关端(The Server&#x2F;Gateway Side)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6-%E4%B8%A4%E9%9D%A2%E6%B4%BE%E7%9A%84%E7%BB%84%E4%BB%B6-Middleware-Components-that-Play-Both-Sides"><span class="nav-number">4.3.</span> <span class="nav-text">中间件: 两面派的组件 (Middleware: Components that Play Both Sides)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%84%E8%8C%83%E7%BB%86%E8%8A%82-Specification-Details"><span class="nav-number">5.</span> <span class="nav-text">规范细节(Specification Details)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#environ-%E5%8F%98%E9%87%8F-environ-Variables"><span class="nav-number">5.1.</span> <span class="nav-text">environ 变量(environ Variables)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E9%94%99%E8%AF%AF%E6%B5%81-Input-and-Error-Streams"><span class="nav-number">5.1.1.</span> <span class="nav-text">输入流和错误流(Input and Error Streams)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E7%9A%84start-response-The-start-response-Callable"><span class="nav-number">5.2.</span> <span class="nav-text">可调用的start_response()(The start_response() Callable)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86Content-Length-Handling-the-Content-Length-Header"><span class="nav-number">5.2.1.</span> <span class="nav-text">处理Content-Length(Handling the Content-Length Header)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%92%8C%E6%B5%81-Buffering-and-Streaming"><span class="nav-number">5.3.</span> <span class="nav-text">缓冲和流(Buffering and Streaming)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E5%9D%97%E8%BE%B9%E7%95%8C%E7%9A%84%E5%A4%84%E7%90%86-Middleware-Handling-of-Block-Boundaries"><span class="nav-number">5.3.1.</span> <span class="nav-text">中间件对块边界的处理(Middleware Handling of Block Boundaries)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%B0%83%E7%94%A8%E7%9A%84write-The-write-Callable"><span class="nav-number">5.3.2.</span> <span class="nav-text">可调用的write()(The write() Callable)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unicode%E9%97%AE%E9%A2%98-Unicode-Issues"><span class="nav-number">5.4.</span> <span class="nav-text">Unicode问题(Unicode Issues)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-Error-Handling"><span class="nav-number">5.5.</span> <span class="nav-text">错误处理(Error Handling)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-1-1%E6%9C%9F%E6%9C%9B-%E7%BB%A7%E7%BB%AD-HTTP-1-1-Expect-Continue"><span class="nav-number">5.6.</span> <span class="nav-text">HTTP 1.1期望&#x2F;继续(HTTP 1.1 Expect&#x2F;Continue)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E7%9A%84HTTP%E7%89%B9%E6%80%A7-Other-HTTP-Features"><span class="nav-number">5.7.</span> <span class="nav-text">其它的HTTP特性(Other HTTP Features)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81-Thread-Support"><span class="nav-number">5.8.</span> <span class="nav-text">线程支持(Thread Support)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lt-a-id-%E2%80%9Dimplementation-application-notes-gt-%E5%AE%9E%E7%8E%B0-%E5%BA%94%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-Implementation-Application-Notes"><span class="nav-number">6.</span> <span class="nav-text">&lt;a id&#x3D;”implementation-application-notes&gt;实现&#x2F;应用注意事项(Implementation&#x2F;Application Notes)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8B%93%E5%B1%95APIs-Server-Extension-APIs"><span class="nav-number">6.1.</span> <span class="nav-text">服务器拓展APIs(Server Extension APIs)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E9%85%8D%E7%BD%AE-Application-Configuration"><span class="nav-number">6.2.</span> <span class="nav-text">应用配置(Application Configuration)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URL%E9%87%8D%E6%9E%84-URL-Reconstruction"><span class="nav-number">6.3.</span> <span class="nav-text">URL重构(URL Reconstruction)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81-lt-2-2-%E8%80%81%E7%89%88%E6%9C%AC%E7%9A%84Python-Supporting-Older-lt-2-2-Versions-of-Python"><span class="nav-number">6.4.</span> <span class="nav-text">支持(&lt;2.2)老版本的Python(Supporting Older (&lt;2.2) Versions of Python)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E7%9A%84%E7%89%B9%E5%AE%9A%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86-Optional-Platform-Specific-File-Handling"><span class="nav-number">6.5.</span> <span class="nav-text">可选的特定平台的文件处理(Optional Platform-Specific File Handling)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E5%9B%9E%E7%AD%94-Questions-and-Answers"><span class="nav-number">7.</span> <span class="nav-text">问题和回答(Questions and Answers)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%9F%E8%AE%AE-%E8%AE%A8%E8%AE%BA%E4%B8%AD-Proposed-Under-Discussion"><span class="nav-number">8.</span> <span class="nav-text">拟议&#x2F;讨论中(Proposed&#x2F;Under Discussion)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%B4%E8%B0%A2-Acknowledgements"><span class="nav-number">9.</span> <span class="nav-text">致谢(Acknowledgements)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-References"><span class="nav-number">10.</span> <span class="nav-text">参考资料(References)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%88%E6%9D%83-Copyright"><span class="nav-number">11.</span> <span class="nav-text">版权(Copyright)</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wang Yibing</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
